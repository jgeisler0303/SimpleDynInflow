% aerodynAeroQSFieldmodal Calculate aerodynamic fields including modal
%           influences
%
% This function calls aerodynAeroQSField to calculate steady state data for
% rotor effective load coefficients over a whole range of tip speed ratios 
% and pitch angles.
% The data is rearranged to the format required by the simplified models
% generated by https://github.com/jgeisler0303/CADynTurb .
% Further, the data is augmented by rotor effective load coefficients under
% the influence of model motion of the blades according to 
% https://doi.org/10.5281/zenodo.5148441 .
%
% Inputs:
%   FST_file    name of the FAST main parameter file
%   data        relevant aerodynamics data as loaded by loadAeroData
%   LambdaVec   vector of tip speed ratios to calculate values for
%   ThetaVec    vector of pitch angles to calculate values for in degrees
%   HubHt       (default: 100) hub height to use in meters
%
% Outputs:
%   AeroFields  structure of aerodynamic fields/tables as required by
%               CADynTurb
%
% See also: aerodynAeroField, calcMeanField


function AeroFields= aerodynAeroQSFieldmodal(FST_file, data, LambdaVec, ThetaVec, HubHt)
if ~exist('HubHt', 'var') || isempty(HubHt)
    HubHt= 100;
end

outputs.normal= {'RtAeroCp', 'RtAeroCq', 'RtAeroCt'};
outputs.all= {'Fx', 'Fy', 'VRel'};
af= aerodynAeroQSField(LambdaVec, ThetaVec, FST_file, HubHt, outputs);

AeroFields.lambda= LambdaVec;
AeroFields.theta= ThetaVec;
AeroFields.R= data.R;

AeroFields.lambda_offset= AeroFields.lambda(1);
AeroFields.theta_offset= AeroFields.theta(1);
AeroFields.lambda_scale= 1/diff(AeroFields.lambda(1:2));
AeroFields.theta_scale= 1/diff(AeroFields.theta(1:2));

n_lam= length(LambdaVec);
n_th= length(ThetaVec);
n_R= length(data.R);

Fx= permute(af.Fx, [2 1 3]);
Fy= permute(af.Fy, [2 1 3]); % positive in direction of rotation

dR= diff(data.R);
dRR= repmat(permute(dR, [3 2 1]), n_th, n_lam, 1);

Fx_sect= (Fx(:, :, 1:end-1)+Fx(:, :, 2:end))/2 .* dRR;
Fxi= zeros(n_th, n_lam, n_R);
Fxi(:, :, 1)= 0.5*Fx_sect(:, :, 1);
Fxi(:, :, 2:end-1)= 0.5*(Fx_sect(:, :, 1:end-1)+Fx_sect(:, :, 2:end));
Fxi(:, :, end)= 0.5*Fx_sect(:, :, end);

Fy_sect= (Fy(:, :, 1:end-1)+Fy(:, :, 2:end))/2 .* dRR;
Fyi= zeros(n_th, n_lam, n_R);
Fyi(:, :, 1)= 0.5*Fy_sect(:, :, 1);
Fyi(:, :, 2:end-1)= 0.5*(Fy_sect(:, :, 1:end-1)+Fy_sect(:, :, 2:end));
Fyi(:, :, end)= 0.5*Fy_sect(:, :, end);

Mx_sect= 3*reshape(int_torque_m(reshape(Fy, n_lam*n_th, []), data.R), n_th, n_lam, n_R-1);
Mxi= zeros(n_th, n_lam, n_R);
Mxi(:, :, 1)= 0.5*Mx_sect(:, :, 1);
Mxi(:, :, 2:end-1)= 0.5*(Mx_sect(:, :, 1:end-1)+Mx_sect(:, :, 2:end));
Mxi(:, :, end)= 0.5*Mx_sect(:, :, end);

My_sect= reshape(int_torque_m(reshape(Fx, n_lam*n_th, []), data.R), n_th, n_lam, n_R-1);
Myi= zeros(n_th, n_lam, n_R);
Myi(:, :, 1)= 0.5*My_sect(:, :, 1);
Myi(:, :, 2:end-1)= 0.5*(My_sect(:, :, 1:end-1)+My_sect(:, :, 2:end));
Myi(:, :, end)= 0.5*My_sect(:, :, end);
My= sum(Myi, 3);
My23= sum(Fxi, 3)*2/3*data.R(end);
DMy23= My-My23; % this is the torque that must be applied to the blade root when the thrust is applied at 2/3*R
% The reason for this approach is to save some comupation and model the
% thrust precisely and DMy23 in a simplified way


Fwind= data.rho/2 * pi*data.R(end)^2 * (af.WindSpeed').^2;
FFwind= repmat(Fwind, 1, 1, n_R);
tth= repmat(AeroFields.theta(:), 1, n_lam, n_R);

cti= Fxi*3./FFwind;
csi= -Fyi./FFwind;
cmi= Mxi./FFwind/data.R(end);

AeroFields.ct= af.RtAeroCt';
ct_adjust_sum= repmat((af.RtAeroCt')./sum(cti, 3), 1, 1, n_R);
AeroFields.cti= cti .* ct_adjust_sum;
AeroFields.cmy_D23= DMy23./Fwind/data.R(end);

AeroFields.csi= csi;
AeroFields.cs= sum(AeroFields.csi, 3);

AeroFields.cbxi= (Fxi.*cosd(tth) + Fyi.*sind(tth)) ./ FFwind;
AeroFields.cbyi= (Fxi.*sind(tth) - Fyi.*cosd(tth)) ./ FFwind;

cm_adjust_sum= repmat((af.RtAeroCq')./sum(cmi, 3), 1, 1, n_R);
AeroFields.cmi= cmi .* cm_adjust_sum;
AeroFields.cm= af.RtAeroCq';

AeroFields.cpi= cmi .* repmat(AeroFields.lambda(:)', n_th, 1, n_R);
AeroFields.cp= af.RtAeroCp';

if isfield(data, 'ModalShapes')
    AeroFields.ModalShapes= data.ModalShapes;
    
    for i= 1:length(AeroFields.ModalShapes)
        for idxTheta= 1:n_th
            for idxLambda= 1:n_lam
                AeroFields.(sprintf('cb%di', i))(idxTheta, idxLambda, :)= sum([squeeze(AeroFields.cbxi(idxTheta, idxLambda, :)) squeeze(AeroFields.cbyi(idxTheta, idxLambda, :))] .* AeroFields.ModalShapes{i}, 2);
                AeroFields.(sprintf('cb%d', i))(idxTheta, idxLambda)= sum(AeroFields.(sprintf('cb%di', i))(idxTheta, idxLambda, :));
            end
        end
    end
    
    for i= 1:length(AeroFields.ModalShapes)
        AeroFields= modalDeriv(AeroFields, i, 'cm');
        AeroFields= modalDeriv(AeroFields, i, 'ct');
        AeroFields= modalDeriv(AeroFields, i, 'cs');
        for j= 1:length(AeroFields.ModalShapes)
            AeroFields= modalDeriv(AeroFields, i, sprintf('cb%d', j));
        end
    end
end


function AeroFields= modalDeriv(AeroFields, n_shape, sensor)

sensor_i= [sensor 'i'];

cXi_= AeroFields.(sensor_i);
ni= size(cXi_, 3);
dcXi_dlam= zeros(size(cXi_));
for i= 1:ni
    dcXi_dlam(:, :, i)= gradient(cXi_(:, :, i), AeroFields.lambda, AeroFields.theta);
end

nth= size(dcXi_dlam, 1);
nlam= size(dcXi_dlam, 2);
nseg= size(dcXi_dlam, 3);

LAM= repmat(AeroFields.lambda(:)', nth, 1, nseg);
R= AeroFields.R(:);
RR= repmat(permute(R(:), [3 2 1]), nth, nlam, 1);
COS= repmat(cosd(AeroFields.theta(:)), 1, nlam, nseg);
SIN= repmat(sind(AeroFields.theta(:)), 1, nlam, nseg);

% vx = axial positive down wind
dcXi_dvx_v= dcXi_dlam .* -LAM; % dcXi_dvx_v= dcXi_dvx * v;

% vy = tangential positiv in direction of positive rotation
dcXi_dom_v= dcXi_dlam * R(end); % dcXi_dom_v= dcXi_dom * v;
dcXi_dvy_v= dcXi_dom_v ./ RR;

% verified in cx_qe_qf.wxmx
ModalShapeX= repmat(permute(AeroFields.ModalShapes{n_shape}(:, 1), [3 2 1]), nth, nlam, 1);
ModalShapeY= repmat(permute(AeroFields.ModalShapes{n_shape}(:, 2), [3 2 1]), nth, nlam, 1);

dcXi_dvbx_v= (-dcXi_dvx_v .* COS + dcXi_dvy_v .* SIN - 2*COS.*AeroFields.(sensor_i));
dcXi_dvby_v= (-dcXi_dvx_v .* SIN - dcXi_dvy_v .* COS - 2*SIN.*AeroFields.(sensor_i));

AeroFields.(sprintf('d%s_dvb%d_v', sensor, n_shape))= sum(dcXi_dvbx_v.*ModalShapeX, 3) + sum(dcXi_dvby_v.*ModalShapeY, 3);

AeroFields.(sprintf('d%si_dvx_v', sensor))= dcXi_dvx_v;
AeroFields.(sprintf('d%si_dvy_v', sensor))= dcXi_dvy_v;
AeroFields.(sprintf('d%si_dom_v', sensor))= dcXi_dom_v;
AeroFields.(sprintf('d%si_dvbx_v', sensor))= dcXi_dvbx_v;
AeroFields.(sprintf('d%si_dvby_v', sensor))= dcXi_dvby_v;

